{"id":"ct-1e8a2b90","title":"Implement Zwischenzug detector (heuristic)","description":"NEW heuristic detector for intermediate moves (intermezzo).\n\nAlgorithm:\n- Requires engine eval data (eval_before, eval_after, best_line from TacticalContext)\n- Tag Zwischenzug when ALL of:\n  1. The played move is forcing (check or capture)\n  2. It occurs in a local exchange context (previous move was capture OR current move is capture)\n  3. The move is NOT the top engine move (it's an intermezzo, not the main line)\n  4. Evaluation swing is significant (\u003e 50cp favorable shift or maintains advantage)\n- Confidence: medium (0.4-0.6), conservative is fine\n- Emit TacticalTag { kind: Zwischenzug, attacker: moved piece square, victims: [], target_square: move destination, confidence, note: short explanation }\n\nThis detector needs the played move + eval context, making it move-relative rather than purely geometric.\n\nDepends on: ct-ba75d59f (TacticalDetector trait).","status":"open","priority":3,"issue_type":"task","owner":"benedikt.schnatterbeck@fresha.com","created_at":"2026-02-21T23:45:03Z","created_by":"Benedikt Schnatterbeck","updated_at":"2026-02-21T23:52:13Z","labels":["tactical-pipeline"],"dependencies":[{"issue_id":"ct-1e8a2b90","depends_on_id":"ct-ba75d59f","type":"blocks","created_at":"2026-02-21T23:46:37Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-1e8a2b90","depends_on_id":"ct-f901f2c8","type":"blocks","created_at":"2026-02-21T23:47:08Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"}]}
{"id":"ct-2f00bfc6","title":"Define TacticalTagKind enum and TacticalTag data model","description":"Replace the current TacticalPattern enum (tactics.rs) with the new data model:\n\n- TacticalTagKind enum: Fork, Pin, Skewer, DiscoveredAttack, DoubleAttack, HangingPiece, Sacrifice, Zwischenzug, BackRankWeakness, MateThreat\n- TacticalTag struct: kind, attacker (Option\u003cString\u003e), victims (Vec\u003cString\u003e), target_square (Option\u003cString\u003e), confidence (f32 0.0..1.0), note (Option\u003cString\u003e), evidence (TacticalEvidence)\n- TacticalEvidence struct: lines (Vec\u003cTacticalLine\u003e), threatened_pieces (Vec\u003cString\u003e), defended_by (Vec\u003cString\u003e)\n- TacticalLine struct: from (String), through (Vec\u003cString\u003e), to (String)\n\nStore squares as 'e4' strings for JSON stability. Keep Serialize/Deserialize derives. Place in analysis/src/board_analysis/tactical_types.rs (new file).\n\nCurrent code to refactor: analysis/src/board_analysis/tactics.rs lines 6-78 (SquareInfo, TacticalPattern, TacticalAnalysis). SquareInfo can be removed once all consumers migrate to string-based squares.","status":"open","priority":3,"issue_type":"task","owner":"benedikt.schnatterbeck@fresha.com","created_at":"2026-02-21T23:43:55Z","created_by":"Benedikt Schnatterbeck","updated_at":"2026-02-21T23:52:13Z","labels":["tactical-pipeline"],"dependencies":[{"issue_id":"ct-2f00bfc6","depends_on_id":"ct-f901f2c8","type":"blocks","created_at":"2026-02-21T23:47:05Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"}]}
{"id":"ct-2f9046bc","title":"Implement Skewer detector","description":"Rework the existing skewer detection from detect_pins_and_skewers() (tactics.rs:173-214) into a standalone detector implementing TacticalDetector.\n\nAlgorithm:\n- Similar to Pin but reversed value ordering: first enemy piece A is MORE valuable than behind piece B\n- Ray trace: sliding piece → front piece A → back piece B\n- If value(A) \u003e value(B) and our slider is on that ray → skewer\n- Confidence increases if A is king (forced to move, exposing B)\n\nEmit TacticalTag { kind: Skewer, attacker: slider square, victims: [front piece, back piece], target_square: None, confidence (0.9 if king front, 0.7 otherwise), evidence with TacticalLine }\n\nDepends on: ct-ba75d59f (TacticalDetector trait), ct-9f92e422 (AttackMap).","status":"open","priority":3,"issue_type":"task","owner":"benedikt.schnatterbeck@fresha.com","created_at":"2026-02-21T23:44:50Z","created_by":"Benedikt Schnatterbeck","updated_at":"2026-02-21T23:52:13Z","labels":["tactical-pipeline"],"dependencies":[{"issue_id":"ct-2f9046bc","depends_on_id":"ct-9f92e422","type":"blocks","created_at":"2026-02-21T23:46:34Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-2f9046bc","depends_on_id":"ct-ba75d59f","type":"blocks","created_at":"2026-02-21T23:46:34Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-2f9046bc","depends_on_id":"ct-f901f2c8","type":"blocks","created_at":"2026-02-21T23:47:07Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"}]}
{"id":"ct-3ff69e18","title":"Wire pipeline orchestrator: run detectors and reduce","description":"Create the top-level pipeline function in analysis/src/board_analysis/pipeline.rs (new file) that replaces the current analyze_tactics().\n\nFunction: detect_tactics(before: \u0026Board, after: \u0026Board, mv: Option\u003cMove\u003e, eval_before: Option\u003ci32\u003e, eval_after: Option\u003ci32\u003e, best_line: Option\u003cVec\u003cString\u003e\u003e) -\u003e Vec\u003cTacticalTag\u003e\n\nSteps:\n1. Build AttackMap for before and after positions\n2. Construct TacticalContext from inputs + attack maps\n3. Run all registered detectors (HangingPiece, Fork/DoubleAttack, Pin, Skewer, DiscoveredAttack, Zwischenzug, BackRankWeakness, MateThreat, Sacrifice)\n4. Collect all Vec\u003cTacticalTag\u003e from detectors\n5. Pass through reducer (merge, dedupe, rank, cap)\n6. Return final Vec\u003cTacticalTag\u003e\n\nThis becomes the new public API replacing analyze_tactics(). The old analyze_tactics() can be deprecated/removed once consumers migrate.\n\nDepends on: ct-ba75d59f (trait), ct-9db898a6 (reducer), and all detector tasks.","status":"open","priority":3,"issue_type":"task","owner":"benedikt.schnatterbeck@fresha.com","created_at":"2026-02-21T23:45:27Z","created_by":"Benedikt Schnatterbeck","updated_at":"2026-02-21T23:52:13Z","labels":["tactical-pipeline"],"dependencies":[{"issue_id":"ct-3ff69e18","depends_on_id":"ct-1e8a2b90","type":"blocks","created_at":"2026-02-21T23:46:42Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-3ff69e18","depends_on_id":"ct-2f9046bc","type":"blocks","created_at":"2026-02-21T23:46:42Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-3ff69e18","depends_on_id":"ct-50d52ab1","type":"blocks","created_at":"2026-02-21T23:46:41Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-3ff69e18","depends_on_id":"ct-51018430","type":"blocks","created_at":"2026-02-21T23:46:43Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-3ff69e18","depends_on_id":"ct-9db898a6","type":"blocks","created_at":"2026-02-21T23:46:40Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-3ff69e18","depends_on_id":"ct-ba75d59f","type":"blocks","created_at":"2026-02-21T23:46:40Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-3ff69e18","depends_on_id":"ct-bd35649a","type":"blocks","created_at":"2026-02-21T23:46:41Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-3ff69e18","depends_on_id":"ct-c6bc09e0","type":"blocks","created_at":"2026-02-21T23:46:41Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-3ff69e18","depends_on_id":"ct-c8bcb338","type":"blocks","created_at":"2026-02-21T23:46:43Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-3ff69e18","depends_on_id":"ct-d131eae2","type":"blocks","created_at":"2026-02-21T23:46:43Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-3ff69e18","depends_on_id":"ct-f901f2c8","type":"blocks","created_at":"2026-02-21T23:47:09Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-3ff69e18","depends_on_id":"ct-fa8f15d7","type":"blocks","created_at":"2026-02-21T23:46:42Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"}]}
{"id":"ct-50d52ab1","title":"Implement Pin detector","description":"Rework the existing pin detection from detect_pins_and_skewers() (tactics.rs:173-214) into a standalone detector implementing TacticalDetector.\n\nAlgorithm:\n- For each sliding piece (bishop/rook/queen) of the side who just moved:\n  - For each direction: ray trace until hitting piece A\n  - Continue ray; if next piece B exists and B is higher value (king = absolute pin, queen/rook = relative pin)\n  - If A belongs to opponent and B belongs to opponent → pin exists\n- Emit TacticalTag { kind: Pin, attacker: pinner square, victims: [pinned piece square], target_square: pinned_to square, confidence (1.0 if pinned to king, 0.8 otherwise), evidence with TacticalLine }\n\nCan also use AttackMap.pins() if pre-computed during AttackMap construction.\n\nImprovement over current: confidence scoring, evidence lines, uses AttackMap for consistency.\n\nDepends on: ct-ba75d59f (TacticalDetector trait), ct-9f92e422 (AttackMap).","status":"open","priority":3,"issue_type":"task","owner":"benedikt.schnatterbeck@fresha.com","created_at":"2026-02-21T23:44:46Z","created_by":"Benedikt Schnatterbeck","updated_at":"2026-02-21T23:52:13Z","labels":["tactical-pipeline"],"dependencies":[{"issue_id":"ct-50d52ab1","depends_on_id":"ct-9f92e422","type":"blocks","created_at":"2026-02-21T23:46:33Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-50d52ab1","depends_on_id":"ct-ba75d59f","type":"blocks","created_at":"2026-02-21T23:46:33Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-50d52ab1","depends_on_id":"ct-f901f2c8","type":"blocks","created_at":"2026-02-21T23:47:07Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"}]}
{"id":"ct-51018430","title":"Implement MateThreat detector (heuristic)","description":"NEW heuristic detector for mate threats.\n\nAlgorithm:\n- Primary: check if eval_after shows mate score (Mate(N) for small N) — confidence 1.0\n- Secondary: check if the PV line ends in checkmate within 3-5 moves — confidence 0.8\n- Geometric heuristic: after the played move, check if the opponent's king has limited escape squares AND our pieces threaten the king zone — confidence 0.4-0.6\n\nEmit TacticalTag { kind: MateThreat, attacker: key attacking piece, victims: [king square], confidence, note: 'Mate in N' or 'Mate threat', evidence }\n\nThis is semi-heuristic: engine eval provides high-confidence signals, geometry provides lower-confidence ones.\n\nDepends on: ct-ba75d59f (TacticalDetector trait), ct-9f92e422 (AttackMap).","status":"open","priority":3,"issue_type":"task","owner":"benedikt.schnatterbeck@fresha.com","created_at":"2026-02-21T23:45:12Z","created_by":"Benedikt Schnatterbeck","updated_at":"2026-02-21T23:52:13Z","labels":["tactical-pipeline"],"dependencies":[{"issue_id":"ct-51018430","depends_on_id":"ct-9f92e422","type":"blocks","created_at":"2026-02-21T23:46:36Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-51018430","depends_on_id":"ct-ba75d59f","type":"blocks","created_at":"2026-02-21T23:46:36Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-51018430","depends_on_id":"ct-f901f2c8","type":"blocks","created_at":"2026-02-21T23:47:09Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"}]}
{"id":"ct-66af127a","title":"Comprehensive FEN-based unit tests for all detectors","description":"Write thorough unit tests for every detector module in analysis/src/board_analysis/.\n\nFor each detector, create tests with known FEN positions:\n- Fork: knight fork king+rook, pawn fork two minors, queen fork (negative: no fork when only 1 target)\n- Pin: absolute pin (to king), relative pin (to queen), bishop pin, rook pin (negative: no pin through own piece)\n- Skewer: king skewer, queen-rook skewer (negative: front piece less valuable = pin not skewer)\n- DiscoveredAttack: bishop revealed by knight move, rook revealed by bishop move (negative: blocker not on ray)\n- HangingPiece: undefended knight, outnumbered rook (negative: defended piece, pawn excluded)\n- BackRankWeakness: classic back rank with pawns blocking (negative: escape square available)\n- Zwischenzug: intermediate check during exchange (needs eval mock data)\n- MateThreat: mate-in-2 position (needs eval mock), geometric near-mate\n- Sacrifice: piece sac with eval improvement (needs eval mock)\n- DoubleAttack: queen attacking two pieces (not knight = no fork tag)\n\nAlso test the reducer: overlapping Fork+DoubleAttack deduplication, confidence cap, max tags per ply.\n\nTest the full pipeline: detect_tactics() end-to-end with known positions.\n\nDepends on: all detector tasks, pipeline orchestrator task.","status":"open","priority":3,"issue_type":"task","owner":"benedikt.schnatterbeck@fresha.com","created_at":"2026-02-21T23:45:59Z","created_by":"Benedikt Schnatterbeck","updated_at":"2026-02-21T23:52:13Z","labels":["tactical-pipeline"],"dependencies":[{"issue_id":"ct-66af127a","depends_on_id":"ct-3ff69e18","type":"blocks","created_at":"2026-02-21T23:46:47Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-66af127a","depends_on_id":"ct-f901f2c8","type":"blocks","created_at":"2026-02-21T23:47:11Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"}]}
{"id":"ct-6b2922a1","title":"Update compute_advanced_analysis to use new tactical pipeline","description":"Refactor server/src/review/advanced/compute.rs to call the new detect_tactics() pipeline instead of the old analyze_tactics().\n\nCurrent code (compute.rs:42-57):\n- Calls analyze_tactics(\u0026board, color) separately for before/after positions\n- Stores TacticalAnalysis in AdvancedPositionAnalysis.tactics_before / tactics_after\n\nNew approach:\n- Call detect_tactics(board_before, board_after, played_move, eval_before, eval_after, pv) once per ply\n- The pipeline handles both positions internally\n- Store Vec\u003cTacticalTag\u003e instead of TacticalAnalysis\n- Update AdvancedPositionAnalysis to hold Vec\u003cTacticalTag\u003e (or a new wrapper) instead of two TacticalAnalysis fields\n- Pass the played move (parse from PositionReview) and eval data from the engine phase\n\nAlso update empty_tactical_analysis() helper and is_critical_position() if it depends on TacticalAnalysis shape.\n\nDepends on: pipeline orchestrator task, ct-2f00bfc6 (data model).","status":"open","priority":3,"issue_type":"task","owner":"benedikt.schnatterbeck@fresha.com","created_at":"2026-02-21T23:45:34Z","created_by":"Benedikt Schnatterbeck","updated_at":"2026-02-21T23:52:13Z","labels":["tactical-pipeline"],"dependencies":[{"issue_id":"ct-6b2922a1","depends_on_id":"ct-2f00bfc6","type":"blocks","created_at":"2026-02-21T23:46:45Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-6b2922a1","depends_on_id":"ct-3ff69e18","type":"blocks","created_at":"2026-02-21T23:46:45Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-6b2922a1","depends_on_id":"ct-f901f2c8","type":"blocks","created_at":"2026-02-21T23:47:10Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"}]}
{"id":"ct-7d991545","title":"Update TUI rendering for new TacticalTag format","description":"Update client-tui widgets to render the new TacticalTag format.\n\nFiles to update:\n- client-tui/src/ui/widgets/move_analysis_panel.rs — renders per-ply inline tactics\n- client-tui/src/ui/widgets/advanced_analysis_panel.rs — renders game-wide tactical detail\n- client-tui/src/ui/widgets/board_overlay.rs — renders tactical arrows/highlights on board\n- client-tui/src/ui/widgets/review_tabs_panel.rs — tactical tab content\n\nChanges:\n- Replace TacticalPattern variant matching with TacticalTagKind matching\n- Use TacticalTag.attacker/victims/target_square for arrow/highlight rendering\n- Display confidence as percentage or bar\n- Show TacticalTag.note as tooltip/detail text\n- Handle new tag kinds: DoubleAttack, Sacrifice, Zwischenzug, MateThreat\n- Use confidence to color-code or dim low-confidence tags\n\nDepends on: proto update task.","status":"open","priority":3,"issue_type":"task","owner":"benedikt.schnatterbeck@fresha.com","created_at":"2026-02-21T23:45:50Z","created_by":"Benedikt Schnatterbeck","updated_at":"2026-02-21T23:52:13Z","labels":["tactical-pipeline"],"dependencies":[{"issue_id":"ct-7d991545","depends_on_id":"ct-d2c7bd3f","type":"blocks","created_at":"2026-02-21T23:46:47Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-7d991545","depends_on_id":"ct-f901f2c8","type":"blocks","created_at":"2026-02-21T23:47:11Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"}]}
{"id":"ct-9db898a6","title":"Implement merge/dedupe/rank reducer","description":"Create the Phase C reducer in analysis/src/board_analysis/reducer.rs (new file).\n\nFunction: reduce_tags(tags: Vec\u003cTacticalTag\u003e, max_per_ply: usize) -\u003e Vec\u003cTacticalTag\u003e\n\nLogic:\n1. Merge tags with same attacker+victims (keep higher confidence)\n2. Dedupe overlapping: if Fork exists, suppress generic DoubleAttack for same squares\n3. Rank by confidence descending\n4. Cap to max_per_ply (default 3) highest-confidence tags\n5. Prefer tags associated with the played move's destination square (boost priority)\n\nQuality rules to encode:\n- Only keep tags involving check, capture, high-value piece, king, or large eval swing\n- Tags below a confidence floor (e.g. 0.1) are dropped\n\nDepends on: ct-2f00bfc6 (TacticalTag model).","status":"open","priority":3,"issue_type":"task","owner":"benedikt.schnatterbeck@fresha.com","created_at":"2026-02-21T23:44:25Z","created_by":"Benedikt Schnatterbeck","updated_at":"2026-02-21T23:52:13Z","labels":["tactical-pipeline"],"dependencies":[{"issue_id":"ct-9db898a6","depends_on_id":"ct-2f00bfc6","type":"blocks","created_at":"2026-02-21T23:46:28Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-9db898a6","depends_on_id":"ct-f901f2c8","type":"blocks","created_at":"2026-02-21T23:47:06Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"}]}
{"id":"ct-9f92e422","title":"Build AttackMap infrastructure","description":"Create a reusable pre-computed AttackMap structure in analysis/src/board_analysis/attack_map.rs (new file).\n\nStructs:\n- Attacker { from: Square, piece: Piece }\n- PinInfo { pinner: Square, pinned: Square, pinned_to: Square, ray: Vec\u003cSquare\u003e }\n- AttackMap { attacked_by_white: per-square attacker lists, attacked_by_black: per-square attacker lists, pins: Vec\u003cPinInfo\u003e }\n\nUse SmallVec\u003c[Attacker; 4]\u003e for per-square attacker lists (most squares have few attackers).\n\nProvide methods:\n- AttackMap::compute(board: \u0026Board) -\u003e AttackMap  (build from scratch)\n- attackers_of(\u0026self, sq: Square, color: Color) -\u003e \u0026[Attacker]\n- is_attacked(\u0026self, sq: Square, color: Color) -\u003e bool\n- pins(\u0026self) -\u003e \u0026[PinInfo]\n\nThis replaces ad-hoc calls to helpers::attackers_of() and helpers::attacked_squares() inside detectors. The existing helpers.rs functions remain available for other consumers (king_safety, tension) but detectors should use AttackMap.\n\nDependencies: Add smallvec to analysis/Cargo.toml.","status":"open","priority":3,"issue_type":"task","owner":"benedikt.schnatterbeck@fresha.com","created_at":"2026-02-21T23:44:05Z","created_by":"Benedikt Schnatterbeck","updated_at":"2026-02-21T23:52:13Z","labels":["tactical-pipeline"],"dependencies":[{"issue_id":"ct-9f92e422","depends_on_id":"ct-f901f2c8","type":"blocks","created_at":"2026-02-21T23:47:05Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"}]}
{"id":"ct-b7aac032","title":"Update server-side proto conversions","description":"Update the conversion layer between analysis crate types and proto types in the server.\n\nFiles to update:\n- Any From/Into impls converting TacticalAnalysis → TacticalAnalysisProto\n- Any From/Into impls converting TacticalPattern → TacticalPatternProto\n- Replace with TacticalTag → TacticalTagProto conversions\n- Update AdvancedPositionAnalysis → AdvancedPositionAnalysisProto conversion\n\nSearch for: 'TacticalPatternProto', 'TacticalAnalysisProto', 'SquareInfoProto' in server/ and proto/ to find all conversion points.\n\nDepends on: proto update task, server integration task.","status":"open","priority":3,"issue_type":"task","owner":"benedikt.schnatterbeck@fresha.com","created_at":"2026-02-21T23:45:45Z","created_by":"Benedikt Schnatterbeck","updated_at":"2026-02-21T23:52:13Z","labels":["tactical-pipeline"],"dependencies":[{"issue_id":"ct-b7aac032","depends_on_id":"ct-6b2922a1","type":"blocks","created_at":"2026-02-21T23:46:47Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-b7aac032","depends_on_id":"ct-d2c7bd3f","type":"blocks","created_at":"2026-02-21T23:46:46Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-b7aac032","depends_on_id":"ct-f901f2c8","type":"blocks","created_at":"2026-02-21T23:47:10Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"}]}
{"id":"ct-ba75d59f","title":"Define TacticalDetector trait and TacticalContext","description":"Create the detector trait framework in analysis/src/board_analysis/detector.rs (new file).\n\nStructs/traits:\n- TacticalContext\u003c'a\u003e { before: \u0026Board, after: \u0026Board, mv: Option\u003cMove\u003e, side_to_move_before: Color, before_attacks: \u0026AttackMap, after_attacks: \u0026AttackMap, eval_before: Option\u003ci32\u003e, eval_after: Option\u003ci32\u003e, best_line: Option\u003cVec\u003cString\u003e\u003e }\n- trait TacticalDetector { fn detect(\u0026self, ctx: \u0026TacticalContext) -\u003e Vec\u003cTacticalTag\u003e; }\n\nThe context carries both positions + attack maps + optional engine info. Each detector is a zero-sized struct implementing the trait. The pipeline calls detect() on each registered detector and collects all tags.\n\nDepends on: ct-2f00bfc6 (TacticalTag model), ct-9f92e422 (AttackMap).","status":"open","priority":3,"issue_type":"task","owner":"benedikt.schnatterbeck@fresha.com","created_at":"2026-02-21T23:44:19Z","created_by":"Benedikt Schnatterbeck","updated_at":"2026-02-21T23:52:13Z","labels":["tactical-pipeline"],"dependencies":[{"issue_id":"ct-ba75d59f","depends_on_id":"ct-2f00bfc6","type":"blocks","created_at":"2026-02-21T23:46:27Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-ba75d59f","depends_on_id":"ct-9f92e422","type":"blocks","created_at":"2026-02-21T23:46:28Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-ba75d59f","depends_on_id":"ct-f901f2c8","type":"blocks","created_at":"2026-02-21T23:47:05Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"}]}
{"id":"ct-bd35649a","title":"Implement Fork and DoubleAttack detector","description":"Rework the existing detect_forks() (tactics.rs:127-170) into a standalone detector implementing TacticalDetector.\n\nAlgorithm:\n- Find the moved piece (from ctx.mv) in after position at move.to\n- Compute all squares it attacks via AttackMap\n- Collect attacked enemy pieces among those squares\n- If \u003e= 2 valuable victims (king/queen/rook/minor): emit DoubleAttack\n- If attacker is knight: also emit Fork (higher confidence)\n- Boost confidence if the move is also a check\n\nEmit TacticalTag with: attacker square, victims list, target_square = fork square, confidence (0.7-1.0 depending on piece types), evidence.\n\nImprovement over current: distinguishes Fork vs DoubleAttack, move-relative (uses played move, not just static position), confidence scoring.\n\nDepends on: ct-ba75d59f (TacticalDetector trait), ct-9f92e422 (AttackMap).","status":"open","priority":3,"issue_type":"task","owner":"benedikt.schnatterbeck@fresha.com","created_at":"2026-02-21T23:44:41Z","created_by":"Benedikt Schnatterbeck","updated_at":"2026-02-21T23:52:13Z","labels":["tactical-pipeline"],"dependencies":[{"issue_id":"ct-bd35649a","depends_on_id":"ct-9f92e422","type":"blocks","created_at":"2026-02-21T23:46:33Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-bd35649a","depends_on_id":"ct-ba75d59f","type":"blocks","created_at":"2026-02-21T23:46:32Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-bd35649a","depends_on_id":"ct-f901f2c8","type":"blocks","created_at":"2026-02-21T23:47:07Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"}]}
{"id":"ct-c359e307","title":"Remove legacy TacticalPattern/TacticalAnalysis and clean up","description":"Once all consumers have migrated to the new TacticalTag model:\n\n1. Remove old types from analysis/src/board_analysis/tactics.rs: SquareInfo, TacticalPattern enum, TacticalAnalysis struct, analyze_tactics() function, and all detect_* helper functions\n2. Update analysis/src/board_analysis/mod.rs exports to expose new pipeline API\n3. Remove old proto messages: TacticalPatternProto (oneof), ForkProto, PinProto, SkewerProto, etc., TacticalAnalysisProto\n4. Clean up any remaining references in server/, client-tui/, chess-client/\n5. Update analysis/src/advanced/critical.rs if it references TacticalAnalysis fields (fork_count, pin_count, etc.) — adapt to use Vec\u003cTacticalTag\u003e filtering instead\n\nThis is the final cleanup task after all integration is complete.\n\nDepends on: server integration, proto update, TUI update, server conversions tasks.","status":"open","priority":3,"issue_type":"task","owner":"benedikt.schnatterbeck@fresha.com","created_at":"2026-02-21T23:46:05Z","created_by":"Benedikt Schnatterbeck","updated_at":"2026-02-21T23:52:13Z","labels":["tactical-pipeline"],"dependencies":[{"issue_id":"ct-c359e307","depends_on_id":"ct-6b2922a1","type":"blocks","created_at":"2026-02-21T23:46:48Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-c359e307","depends_on_id":"ct-7d991545","type":"blocks","created_at":"2026-02-21T23:46:48Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-c359e307","depends_on_id":"ct-b7aac032","type":"blocks","created_at":"2026-02-21T23:46:49Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-c359e307","depends_on_id":"ct-d2c7bd3f","type":"blocks","created_at":"2026-02-21T23:46:48Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-c359e307","depends_on_id":"ct-f901f2c8","type":"blocks","created_at":"2026-02-21T23:47:11Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"}]}
{"id":"ct-c6bc09e0","title":"Implement HangingPiece detector","description":"Rework the existing detect_hanging_pieces() (tactics.rs:258-282) into a standalone detector implementing TacticalDetector.\n\nAlgorithm (on after position):\n- For each enemy piece square: compute attackers_by_us and defenders_by_them from AttackMap\n- Mark hanging if: defenders empty AND attackers non-empty (confidence: 0.9), OR outnumbered via basic SEE-lite (confidence: 0.6)\n- Emit TacticalTag { kind: HangingPiece, attacker: lowest-value attacker square, victims: [hanging piece square], confidence, evidence with threatened_pieces + defended_by }\n\nCurrent code excludes pawns — keep that (too noisy). Include knights, bishops, rooks, queens.\n\nImprovement over current: add confidence scoring, SEE-lite for outnumbered cases, and evidence fields.\n\nDepends on: ct-ba75d59f (TacticalDetector trait), ct-9f92e422 (AttackMap).","status":"open","priority":3,"issue_type":"task","owner":"benedikt.schnatterbeck@fresha.com","created_at":"2026-02-21T23:44:34Z","created_by":"Benedikt Schnatterbeck","updated_at":"2026-02-21T23:52:13Z","labels":["tactical-pipeline"],"dependencies":[{"issue_id":"ct-c6bc09e0","depends_on_id":"ct-9f92e422","type":"blocks","created_at":"2026-02-21T23:46:32Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-c6bc09e0","depends_on_id":"ct-ba75d59f","type":"blocks","created_at":"2026-02-21T23:46:31Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-c6bc09e0","depends_on_id":"ct-f901f2c8","type":"blocks","created_at":"2026-02-21T23:47:06Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"}]}
{"id":"ct-c8bcb338","title":"Implement Sacrifice detector (heuristic)","description":"NEW heuristic detector for sacrifices.\n\nAlgorithm:\n- The played move captures a piece of lower value (or moves to a square where it's captured) AND leads to significant eval improvement or tactical advantage\n- Detect: piece moved to a square where it's attacked by lower-value enemy pieces AND eval_after is equal or better than eval_before (the material loss is compensated)\n- Also detect: move is a capture where piece_value(captured) \u003c piece_value(capturer) but eval improves\n- Confidence: 0.5-0.8 based on eval swing magnitude\n\nEmit TacticalTag { kind: Sacrifice, attacker: sacrificed piece square, victims: [], target_square: sacrifice square, confidence, note: short explanation, evidence }\n\nRequires eval data for reliable detection. Without eval, skip or use very low confidence.\n\nDepends on: ct-ba75d59f (TacticalDetector trait), ct-9f92e422 (AttackMap).","status":"open","priority":3,"issue_type":"task","owner":"benedikt.schnatterbeck@fresha.com","created_at":"2026-02-21T23:45:17Z","created_by":"Benedikt Schnatterbeck","updated_at":"2026-02-21T23:52:13Z","labels":["tactical-pipeline"],"dependencies":[{"issue_id":"ct-c8bcb338","depends_on_id":"ct-9f92e422","type":"blocks","created_at":"2026-02-21T23:46:37Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-c8bcb338","depends_on_id":"ct-ba75d59f","type":"blocks","created_at":"2026-02-21T23:46:36Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-c8bcb338","depends_on_id":"ct-f901f2c8","type":"blocks","created_at":"2026-02-21T23:47:09Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"}]}
{"id":"ct-cli","title":"Create chesstty Crate \u0026 CLI Interface","description":"## What\nScaffold the new `chesstty` binary crate that serves as the single entry point for the application. Implement the clap-based CLI with two modes: default (no args) launches server+TUI, and the `engine stop` subcommand signals the server to shut down.\n\n## File(s)\n- `chesstty/chesstty/Cargo.toml` (new)\n- `chesstty/chesstty/src/main.rs` (new)\n- `chesstty/chesstty/src/cli.rs` (new)\n- `Cargo.toml` (add `chesstty` to workspace members)\n\n## Implementation Details\n```rust\nuse clap::{Parser, Subcommand};\n\n#[derive(Parser)]\n#[command(name = \"chesstty\", about = \"Chess TUI with integrated engine analysis\")]\nstruct Cli {\n    #[command(subcommand)]\n    command: Option\u003cCommands\u003e,\n}\n\n#[derive(Subcommand)]\nenum Commands {\n    /// Manage the engine server\n    Engine {\n        #[command(subcommand)]\n        action: EngineAction,\n    },\n}\n\n#[derive(Subcommand)]\nenum EngineAction {\n    /// Stop the background engine server\n    Stop {\n        /// Force immediate shutdown (SIGKILL instead of SIGTERM)\n        #[arg(short, long)]\n        force: bool,\n    },\n}\n```\n\n- Default (None): orchestrate server launch + TUI (implementation in later task)\n- `engine stop`: signal server shutdown (implementation in later task)\n- main.rs: match on cli.command, dispatch to handler stubs\n\n## Dependencies\n- clap = { version = \"4\", features = [\"derive\"] }\n- tokio = { version = \"1.41\", features = [\"full\"] }\n- anyhow = \"1.0\"\n- tracing, tracing-subscriber\n\n## Acceptance Criteria\n- [ ] `chesstty/chesstty/` crate exists with Cargo.toml and src/main.rs\n- [ ] Crate is listed in workspace members in root Cargo.toml\n- [ ] `cargo build -p chesstty` compiles successfully\n- [ ] `cargo run -p chesstty -- --help` shows usage with engine subcommand\n- [ ] `cargo run -p chesstty -- engine stop --help` shows --force flag\n- [ ] Default mode (no args) prints placeholder message\n- [ ] Workspace lints (unsafe_code=forbid, enum_glob_use=deny) apply","status":"open","priority":1,"issue_type":"task","owner":"benedikt.schnatterbeck@fresha.com","created_at":"2026-02-21T22:55:12Z","created_by":"Benedikt Schnatterbeck","updated_at":"2026-02-21T23:22:12Z"}
{"id":"ct-cli.1","title":"Scaffold chesstty crate directory and Cargo.toml","description":"Create chesstty/chesstty/ directory. Write Cargo.toml with: name=chesstty, [[bin]] target, dependencies (clap with derive, tokio full, anyhow, tracing, tracing-subscriber). Add 'chesstty' to workspace members in root Cargo.toml. Verify cargo check -p chesstty passes.","status":"open","priority":1,"issue_type":"task","owner":"benedikt.schnatterbeck@fresha.com","created_at":"2026-02-21T22:57:37Z","created_by":"Benedikt Schnatterbeck","updated_at":"2026-02-21T23:22:02Z","dependencies":[{"issue_id":"ct-cli.1","depends_on_id":"ct-cli","type":"parent-child","created_at":"2026-02-21T22:57:37Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"}]}
{"id":"ct-cli.2","title":"Implement clap derive CLI structs","description":"Create src/cli.rs with Cli (Parser), Commands (Subcommand with Option wrapper for default mode), EngineAction (Subcommand with Stop variant), Stop args (-f/--force bool). Follow the exact structure from the parent task description. Export from lib or keep in cli module.","status":"open","priority":1,"issue_type":"task","owner":"benedikt.schnatterbeck@fresha.com","created_at":"2026-02-21T22:57:38Z","created_by":"Benedikt Schnatterbeck","updated_at":"2026-02-21T23:22:05Z","dependencies":[{"issue_id":"ct-cli.2","depends_on_id":"ct-cli","type":"parent-child","created_at":"2026-02-21T22:57:37Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-cli.2","depends_on_id":"ct-cli.1","type":"blocks","created_at":"2026-02-21T23:23:13Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"}]}
{"id":"ct-cli.3","title":"Wire CLI dispatch in main.rs","description":"In main.rs: parse Cli, match on command. None =\u003e call launch_default() stub, Some(Commands::Engine { action: EngineAction::Stop { force } }) =\u003e call stop_server() stub. Stubs print messages for now. Set up tracing_subscriber::init().","status":"open","priority":2,"issue_type":"task","owner":"benedikt.schnatterbeck@fresha.com","created_at":"2026-02-21T22:57:38Z","created_by":"Benedikt Schnatterbeck","updated_at":"2026-02-21T23:22:09Z","dependencies":[{"issue_id":"ct-cli.3","depends_on_id":"ct-cli","type":"parent-child","created_at":"2026-02-21T22:57:37Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-cli.3","depends_on_id":"ct-cli.2","type":"blocks","created_at":"2026-02-21T23:23:13Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"}]}
{"id":"ct-config","title":"Shared Runtime Configuration Module","description":"## What\nCreate a shared configuration module that centralizes all runtime paths and constants used by the shim, server, and client. This ensures the socket path, PID file path, and timeout values are defined once and configurable via environment variables.\n\n## File(s)\n- `chesstty/chesstty/src/config.rs` (new)\n- Alternatively a new shared `chesstty-common` crate, or extend existing `server/src/config.rs`\n\n## Implementation Details\n- Default socket path: `/tmp/chesstty.sock` (override: `CHESSTTY_SOCKET_PATH`)\n- Default PID file path: `/tmp/chesstty.pid` (override: `CHESSTTY_PID_PATH`)\n- Default socket wait timeout: 5 seconds (override: `CHESSTTY_SOCKET_TIMEOUT_SECS`)\n- Default socket wait poll interval: 100ms\n- Follow existing `server/src/config.rs` pattern (env var with fallback to default)\n\n## Acceptance Criteria\n- [ ] Socket path, PID path, and timeout constants are defined with env var overrides\n- [ ] Config is importable from server, client-tui, and the new chesstty shim crate\n- [ ] All values have sensible defaults that work without any env vars set\n- [ ] Existing `server/src/config.rs` pattern (get_data_dir style) is followed","status":"open","priority":1,"issue_type":"task","owner":"benedikt.schnatterbeck@fresha.com","created_at":"2026-02-21T22:54:58Z","created_by":"Benedikt Schnatterbeck","updated_at":"2026-02-21T23:22:00Z"}
{"id":"ct-config.1","title":"Define path constants with env var overrides","description":"Define SOCKET_PATH, PID_PATH, SOCKET_TIMEOUT_SECS, POLL_INTERVAL_MS as constants. Add env var lookup functions following the get_data_dir() pattern in server/src/config.rs. Each function: check env var -\u003e parse -\u003e fall back to default.","status":"open","priority":1,"issue_type":"task","owner":"benedikt.schnatterbeck@fresha.com","created_at":"2026-02-21T22:57:36Z","created_by":"Benedikt Schnatterbeck","updated_at":"2026-02-21T23:20:40Z","dependencies":[{"issue_id":"ct-config.1","depends_on_id":"ct-config","type":"parent-child","created_at":"2026-02-21T22:57:36Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-config.1","depends_on_id":"ct-config.2","type":"blocks","created_at":"2026-02-21T23:23:12Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"}]}
{"id":"ct-config.2","title":"Decide shared config module location","description":"Decision: place config in the chesstty shim crate and re-export, OR create a tiny chesstty-common crate, OR extend server/src/config.rs. Recommended: put in the chesstty shim crate since server and client-tui will depend on it as a library. Document the decision.","status":"open","priority":2,"issue_type":"task","owner":"benedikt.schnatterbeck@fresha.com","created_at":"2026-02-21T22:57:37Z","created_by":"Benedikt Schnatterbeck","updated_at":"2026-02-21T23:21:57Z","dependencies":[{"issue_id":"ct-config.2","depends_on_id":"ct-config","type":"parent-child","created_at":"2026-02-21T22:57:36Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"}]}
{"id":"ct-d131eae2","title":"Implement BackRankWeakness detector","description":"Rework the existing detect_back_rank_weakness() (tactics.rs:285-331) into a standalone detector implementing TacticalDetector.\n\nAlgorithm:\n- King on back rank (rank 1 for White, rank 8 for Black)\n- Escape squares blocked by own pawns/pieces\n- Opponent has rook/queen that can potentially deliver mate on back rank\n- Emit even without immediate tactic (low confidence 0.3)\n- Increase confidence to 0.8+ if PV contains back-rank mate pattern or mate score appears in eval\n\nImprovement over current: confidence scoring (was binary), can use engine eval for boosting, evidence fields.\n\nDepends on: ct-ba75d59f (TacticalDetector trait), ct-9f92e422 (AttackMap).","status":"open","priority":3,"issue_type":"task","owner":"benedikt.schnatterbeck@fresha.com","created_at":"2026-02-21T23:45:07Z","created_by":"Benedikt Schnatterbeck","updated_at":"2026-02-21T23:52:13Z","labels":["tactical-pipeline"],"dependencies":[{"issue_id":"ct-d131eae2","depends_on_id":"ct-9f92e422","type":"blocks","created_at":"2026-02-21T23:46:35Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-d131eae2","depends_on_id":"ct-ba75d59f","type":"blocks","created_at":"2026-02-21T23:46:35Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-d131eae2","depends_on_id":"ct-f901f2c8","type":"blocks","created_at":"2026-02-21T23:47:08Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"}]}
{"id":"ct-d2c7bd3f","title":"Update proto definitions for new TacticalTag model","description":"Rewrite proto/proto/advanced_review.proto tactical messages to match the new data model.\n\nReplace:\n- TacticalPatternProto (oneof with 6 variants) → TacticalTagProto\n- TacticalAnalysisProto (flat counts) → repeated TacticalTagProto\n\nNew proto messages:\n- TacticalTagKindProto (enum): FORK, PIN, SKEWER, DISCOVERED_ATTACK, DOUBLE_ATTACK, HANGING_PIECE, SACRIFICE, ZWISCHENZUG, BACK_RANK_WEAKNESS, MATE_THREAT\n- TacticalLineProto { string from, repeated string through, string to }\n- TacticalEvidenceProto { repeated TacticalLineProto lines, repeated string threatened_pieces, repeated string defended_by }\n- TacticalTagProto { TacticalTagKindProto kind, optional string attacker, repeated string victims, optional string target_square, float confidence, optional string note, TacticalEvidenceProto evidence }\n\nUpdate AdvancedPositionAnalysisProto to replace tactics_before/tactics_after with repeated TacticalTagProto tactical_tags.\n\nRun protobuf codegen after changes. Update proto/src/lib.rs conversion code.\n\nDepends on: ct-2f00bfc6 (data model).","status":"open","priority":3,"issue_type":"task","owner":"benedikt.schnatterbeck@fresha.com","created_at":"2026-02-21T23:45:40Z","created_by":"Benedikt Schnatterbeck","updated_at":"2026-02-21T23:52:13Z","labels":["tactical-pipeline"],"dependencies":[{"issue_id":"ct-d2c7bd3f","depends_on_id":"ct-2f00bfc6","type":"blocks","created_at":"2026-02-21T23:46:46Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-d2c7bd3f","depends_on_id":"ct-f901f2c8","type":"blocks","created_at":"2026-02-21T23:47:10Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"}]}
{"id":"ct-daemon","title":"Shim Process Management — Daemonize, PID, Socket Wait","description":"## What\nImplement the core process management logic in the chesstty shim: PID file reading/stale detection, a native `Daemon` builder for server daemonization (custom double-fork, builder-pattern API, no external crate), and a socket-ready wait loop with timeout.\n\n## File(s)\n- `chesstty/chesstty/src/process.rs` (new) — PID file operations\n- `chesstty/chesstty/src/daemon.rs` (new) — Daemon builder (double-fork + setsid)\n- `chesstty/chesstty/src/wait.rs` (new) — socket wait loop\n- `chesstty/chesstty/Cargo.toml` — add libc dep\n\n## Implementation Details\n\n### PID File Management (process.rs)\n```rust\npub fn is_server_running(pid_path: \u0026Path) -\u003e bool { ... }  // libc::kill(pid, 0)\npub fn read_pid(pid_path: \u0026Path) -\u003e anyhow::Result\u003ci32\u003e { ... }\npub fn remove_stale_pid(pid_path: \u0026Path) -\u003e anyhow::Result\u003c()\u003e { ... }\n```\n\n### Custom Daemonization — Builder Pattern (daemon.rs)\n```rust\nlet stdout = File::create(\"/tmp/chesstty-server.out\")?;\nlet stderr = File::create(\"/tmp/chesstty-server.err\")?;\n\nDaemon::new()\n    .pid_file(config.pid_path())\n    .working_directory(\"/tmp\")\n    .umask(0o027)\n    .stdout(stdout)\n    .stderr(stderr)\n    .start()?;\n\n// Now in daemon process — start tokio runtime\ntokio::runtime::Runtime::new()?.block_on(server::run())?;\n```\n\nSee subtask 5.2 for full API spec. Every method except `new()` and `start()` is optional.\n\n### Socket Wait Loop (wait.rs)\n```rust\npub async fn wait_for_socket(\n    socket_path: \u0026Path,\n    timeout: Duration,\n    poll_interval: Duration,\n) -\u003e anyhow::Result\u003c()\u003e { ... }\n```\n\nTwo-phase check: file exists AND UnixStream::connect() succeeds.\n\n## Acceptance Criteria\n- [ ] `is_server_running()` correctly detects running vs stale PID\n- [ ] Stale PID files (dead process) are detected and cleaned up\n- [ ] `Daemon` builder API with sensible defaults (see subtask 5.2 for full spec)\n- [ ] Server is daemonized using custom double-fork (no daemonize crate)\n- [ ] Socket wait loop succeeds when server starts within timeout\n- [ ] Socket wait loop fails with clear error message after timeout\n- [ ] Socket wait probes actual connectivity (not just file existence)\n- [ ] All fork/setsid calls BEFORE tokio runtime (sync context only)\n- [ ] All unsafe blocks have // SAFETY comments","status":"open","priority":1,"issue_type":"task","owner":"benedikt.schnatterbeck@fresha.com","created_at":"2026-02-21T22:55:55Z","created_by":"Benedikt Schnatterbeck","updated_at":"2026-02-21T23:22:34Z","dependencies":[{"issue_id":"ct-daemon","depends_on_id":"ct-config","type":"blocks","created_at":"2026-02-21T22:57:55Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"}]}
{"id":"ct-daemon.1","title":"PID file read/write/stale detection","description":"In chesstty/src/process.rs: implement is_server_running(pid_path) using fs::read_to_string + parse i32 + libc::kill(pid, 0). Implement read_pid(pid_path) -\u003e Result\u003ci32\u003e. Implement remove_stale_pid(pid_path) that removes file if process is dead. Handle: file not found, invalid content, permission denied. Mark unsafe blocks with // SAFETY comments.","status":"open","priority":1,"issue_type":"task","owner":"benedikt.schnatterbeck@fresha.com","created_at":"2026-02-21T22:57:41Z","created_by":"Benedikt Schnatterbeck","updated_at":"2026-02-21T23:22:24Z","dependencies":[{"issue_id":"ct-daemon.1","depends_on_id":"ct-config","type":"blocks","created_at":"2026-02-21T23:23:01Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-daemon.1","depends_on_id":"ct-daemon","type":"parent-child","created_at":"2026-02-21T22:57:40Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"}]}
{"id":"ct-daemon.2","title":"Custom Daemon builder (double-fork + setsid, builder pattern)","description":"## What\nImplement a `Daemon` builder struct that encapsulates the UNIX double-fork daemonization pattern. No external crate — we own the implementation. The API mirrors the ergonomics of the `daemonize` crate's builder but is our own code, using `libc` directly.\n\n## File(s)\n- `chesstty/chesstty/src/daemon.rs` (new)\n\n## API Design (Builder Pattern)\n\n```rust\nuse std::path::PathBuf;\nuse std::fs::File;\n\npub struct Daemon {\n    pid_file: Option\u003cPathBuf\u003e,\n    chown_pid_file: bool,\n    working_directory: PathBuf,      // default: \"/\"\n    user: Option\u003cString\u003e,\n    group: Option\u003cGroup\u003e,            // String name or u32 gid\n    umask: u32,                      // default: 0o027\n    stdout: Option\u003cFile\u003e,\n    stderr: Option\u003cFile\u003e,\n    privileged_action: Option\u003cBox\u003cdyn FnOnce() -\u003e anyhow::Result\u003c()\u003e\u003e\u003e,\n}\n\npub enum Group {\n    Name(String),\n    Id(u32),\n}\n\nimpl Daemon {\n    pub fn new() -\u003e Self {\n        Self {\n            pid_file: None,\n            chown_pid_file: false,\n            working_directory: PathBuf::from(\"/\"),\n            user: None,\n            group: None,\n            umask: 0o027,\n            stdout: None,\n            stderr: None,\n            privileged_action: None,\n        }\n    }\n\n    pub fn pid_file(mut self, path: impl Into\u003cPathBuf\u003e) -\u003e Self { self.pid_file = Some(path.into()); self }\n    pub fn chown_pid_file(mut self, chown: bool) -\u003e Self { self.chown_pid_file = chown; self }\n    pub fn working_directory(mut self, path: impl Into\u003cPathBuf\u003e) -\u003e Self { self.working_directory = path.into(); self }\n    pub fn user(mut self, user: impl Into\u003cString\u003e) -\u003e Self { self.user = Some(user.into()); self }\n    pub fn group(mut self, group: impl Into\u003cGroup\u003e) -\u003e Self { self.group = Some(group.into()); self }\n    pub fn umask(mut self, mask: u32) -\u003e Self { self.umask = mask; self }\n    pub fn stdout(mut self, f: File) -\u003e Self { self.stdout = Some(f); self }\n    pub fn stderr(mut self, f: File) -\u003e Self { self.stderr = Some(f); self }\n    pub fn privileged_action\u003cF\u003e(mut self, f: F) -\u003e Self\n    where F: FnOnce() -\u003e anyhow::Result\u003c()\u003e + 'static {\n        self.privileged_action = Some(Box::new(f));\n        self\n    }\n\n    /// Execute the double-fork daemonization sequence.\n    ///\n    /// On success, returns Ok(()) in the daemon (grandchild) process.\n    /// The original caller process exits via std::process::exit(0).\n    ///\n    /// Sequence:\n    /// 1. First fork — parent exits\n    /// 2. setsid() — detach from controlling terminal\n    /// 3. Execute privileged_action (if set) — runs before privilege drop\n    /// 4. Drop privileges (user/group, if set)\n    /// 5. Second fork — session leader exits\n    /// 6. umask + chdir\n    /// 7. Redirect stdin→/dev/null, stdout/stderr→configured files\n    /// 8. Write PID file (grandchild PID)\n    pub fn start(self) -\u003e anyhow::Result\u003c()\u003e { ... }\n}\n```\n\n### Usage in the shim (chesstty/src/daemon.rs caller)\n```rust\nlet stdout = File::create(\"/tmp/chesstty-server.out\")?;\nlet stderr = File::create(\"/tmp/chesstty-server.err\")?;\n\nDaemon::new()\n    .pid_file(config.pid_path())\n    .working_directory(\"/tmp\")\n    .umask(0o027)\n    .stdout(stdout)\n    .stderr(stderr)\n    .start()?;\n\n// We are now the daemon — start tokio runtime and run server\ntokio::runtime::Runtime::new()?.block_on(server::run())?;\n```\n\n### Implementation Notes\n- Reference `daemonize` crate source (https://github.com/knsd/daemonize) for edge cases\n- `impl Into\u003cGroup\u003e` for both `\u0026str`/`String` and `u32` to support `.group(\"daemon\")` and `.group(2)`\n- `privileged_action` runs between setsid and privilege drop — useful for binding sockets that need elevated permissions\n- `chown_pid_file`: if true and user/group set, chown the PID file after writing\n- File descriptor redirection via `libc::dup2()`: stdin→/dev/null, stdout→stdout file, stderr→stderr file\n- If stdout/stderr not configured, redirect to /dev/null\n- Consider closing inherited FDs (3..max_fd) to prevent leaking parent's open files\n- All `unsafe` blocks (fork, setsid, umask, dup2, setuid, setgid) require `// SAFETY:` comments\n- `start()` consumes self (moved, not borrowed) — one-shot operation\n\n### Error Type\nConsider a dedicated `DaemonError` enum (via thiserror) rather than stringly-typed anyhow errors:\n```rust\n#[derive(Debug, thiserror::Error)]\npub enum DaemonError {\n    #[error(\"first fork failed: {0}\")]\n    ForkFailed(std::io::Error),\n    #[error(\"setsid failed: {0}\")]\n    SetsidFailed(std::io::Error),\n    #[error(\"failed to write PID file: {0}\")]\n    PidFile(std::io::Error),\n    #[error(\"privilege drop failed: {0}\")]\n    PrivilegeDrop(std::io::Error),\n    #[error(\"privileged action failed: {0}\")]\n    PrivilegedAction(anyhow::Error),\n    // ...\n}\n```\n\n## Acceptance Criteria\n- [ ] `Daemon` struct with builder-pattern API (all setters return Self)\n- [ ] Every method except `new()` and `start()` is optional with sensible defaults\n- [ ] Double-fork implemented correctly (parent exits, grandchild is daemon)\n- [ ] setsid() detaches from controlling terminal\n- [ ] Second fork prevents re-acquiring controlling terminal\n- [ ] privileged_action runs between setsid and privilege drop\n- [ ] User/group privilege drop via setuid/setgid (when configured)\n- [ ] PID file written with daemon's actual PID (grandchild)\n- [ ] PID file optionally chowned to target user/group\n- [ ] stdin→/dev/null, stdout/stderr→configured files (or /dev/null)\n- [ ] Dedicated DaemonError enum (thiserror), not stringly-typed errors\n- [ ] All unsafe blocks have // SAFETY comments\n- [ ] Works on macOS (darwin) and Linux\n- [ ] No external daemonize crate in dependencies","status":"open","priority":1,"issue_type":"task","owner":"benedikt.schnatterbeck@fresha.com","created_at":"2026-02-21T22:57:41Z","created_by":"Benedikt Schnatterbeck","updated_at":"2026-02-21T23:22:27Z","dependencies":[{"issue_id":"ct-daemon.2","depends_on_id":"ct-config","type":"blocks","created_at":"2026-02-21T23:23:01Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-daemon.2","depends_on_id":"ct-daemon","type":"parent-child","created_at":"2026-02-21T22:57:40Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"}]}
{"id":"ct-daemon.3","title":"Socket wait/retry loop with timeout","description":"In chesstty/src/wait.rs: implement wait_for_socket(socket_path, timeout, poll_interval) -\u003e Result\u003c()\u003e. Loop: check Instant::now() \u003e deadline -\u003e bail with error, check path.exists() -\u003e try UnixStream::connect() -\u003e return Ok if success, sleep(poll_interval). Two-phase check: file exists AND connection succeeds. Default timeout 5s, poll interval 100ms. Clear error message includes log file path for debugging.","status":"open","priority":1,"issue_type":"task","owner":"benedikt.schnatterbeck@fresha.com","created_at":"2026-02-21T22:57:41Z","created_by":"Benedikt Schnatterbeck","updated_at":"2026-02-21T23:22:30Z","dependencies":[{"issue_id":"ct-daemon.3","depends_on_id":"ct-config","type":"blocks","created_at":"2026-02-21T23:23:01Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-daemon.3","depends_on_id":"ct-daemon","type":"parent-child","created_at":"2026-02-21T22:57:41Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"}]}
{"id":"ct-f901f2c8","title":"Tactical Pattern Detection Pipeline Rework","description":"Rework tactical detection into a pure-function pipeline: PositionContext → Vec\u003cTacticalTag\u003e. Replace the current flat TacticalPattern enum + TacticalAnalysis with a richer TacticalTag model (kind, attacker, victims, confidence, evidence). Introduce AttackMap as reusable pre-computed structure, a TacticalDetector trait for modular detectors, and a merge/dedupe/rank reducer. Add new detectors: DiscoveredAttack (currently stub), Zwischenzug, MateThreat, Sacrifice, DoubleAttack. Rework existing: Fork, Pin, Skewer, HangingPiece, BackRankWeakness. Update proto/gRPC, server pipeline, and TUI rendering.","status":"open","priority":3,"issue_type":"feature","owner":"benedikt.schnatterbeck@fresha.com","created_at":"2026-02-21T23:43:41Z","created_by":"Benedikt Schnatterbeck","updated_at":"2026-02-21T23:52:13Z","labels":["tactical-pipeline"]}
{"id":"ct-fa8f15d7","title":"Implement DiscoveredAttack detector","description":"NEW detector — the current DiscoveredAttack variant exists in TacticalPattern but detect logic was never implemented (discovered_attack_count is always 0).\n\nAlgorithm (move-relative):\n- Compare before_attacks vs after_attacks from AttackMap\n- Look for squares newly attacked by a slider in after that were NOT attacked in before\n- Check if the blocker that moved away is the played piece (ctx.mv.from was on the ray)\n- If the newly attacked square contains an enemy piece (or king) → discovered attack\n- Emit TacticalTag { kind: DiscoveredAttack, attacker: revealed slider square, victims: [target square], target_square: None, confidence 0.8-1.0 (higher if target is king/queen), evidence with TacticalLine from slider through old blocker position to target }\n\nDepends on: ct-ba75d59f (TacticalDetector trait), ct-9f92e422 (AttackMap).","status":"open","priority":3,"issue_type":"task","owner":"benedikt.schnatterbeck@fresha.com","created_at":"2026-02-21T23:44:56Z","created_by":"Benedikt Schnatterbeck","updated_at":"2026-02-21T23:52:13Z","labels":["tactical-pipeline"],"dependencies":[{"issue_id":"ct-fa8f15d7","depends_on_id":"ct-9f92e422","type":"blocks","created_at":"2026-02-21T23:46:35Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-fa8f15d7","depends_on_id":"ct-ba75d59f","type":"blocks","created_at":"2026-02-21T23:46:34Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-fa8f15d7","depends_on_id":"ct-f901f2c8","type":"blocks","created_at":"2026-02-21T23:47:08Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"}]}
{"id":"ct-launch","title":"Default Launch Lifecycle — Full Orchestration","description":"## What\nWire up the complete default-mode lifecycle in the chesstty shim: check if server is running → if not, daemonize it → wait for socket → launch TUI in the foreground.\n\n## File(s)\n- `chesstty/chesstty/src/main.rs` — default command handler\n- `chesstty/chesstty/src/launch.rs` (new) — launch orchestration\n\n## Implementation Details\n```rust\npub async fn launch_default() -\u003e anyhow::Result\u003c()\u003e {\n    let config = config::RuntimeConfig::load();\n\n    // 1. Check if server is already running\n    if process::is_server_running(\u0026config.pid_path) {\n        tracing::info!(\"Server already running (PID file: {:?})\", config.pid_path);\n    } else {\n        // 2. Clean up any stale state\n        process::remove_stale_pid(\u0026config.pid_path)?;\n        if config.socket_path.exists() {\n            std::fs::remove_file(\u0026config.socket_path)?;\n        }\n\n        // 3. Daemonize the server\n        tracing::info!(\"Starting server daemon...\");\n        daemon::start_server_daemon(\u0026config)?;\n    }\n\n    // 4. Wait for socket to become ready\n    tracing::info!(\"Waiting for server socket...\");\n    wait::wait_for_socket(\n        \u0026config.socket_path,\n        config.socket_timeout,\n        config.poll_interval,\n    ).await?;\n\n    // 5. Launch TUI in foreground\n    tracing::info!(\"Launching TUI...\");\n    // Either:\n    // a) Call client-tui as a library: client_tui::run_app(config.socket_path).await\n    // b) Exec into the client-tui binary: std::process::Command::new(\"client-tui\")\n    // Prefer (a) for better integration\n    Ok(())\n}\n```\n\n### Decision: Library vs Exec for TUI launch\n**Recommended: Library call.** Import client-tui's run function and call it directly. This avoids PATH issues, version skew, and gives better error propagation. Requires client-tui to expose a public `run_app(socket_path)` function.\n\n### Decision: Daemonize boundary\nThe daemonize call forks the process. The parent (shim) continues to step 4. The child (daemon) starts the tokio runtime and runs the server. The shim must NOT have started a tokio runtime before forking — use `std::process::Command` or `daemonize` in a sync context, then start the async runtime for the wait+TUI phase.\n\n## Acceptance Criteria\n- [ ] `cargo run -p chesstty` (no args) starts server daemon and launches TUI\n- [ ] If server is already running, skips daemon launch and goes straight to TUI\n- [ ] Stale PID/socket files are cleaned up before new server launch\n- [ ] TUI connects to server via UDS after socket is ready\n- [ ] Clear error message if server fails to start within timeout\n- [ ] Server continues running after TUI exits (daemon persists)\n- [ ] Tracing logs show each lifecycle step","status":"open","priority":1,"issue_type":"task","owner":"benedikt.schnatterbeck@fresha.com","created_at":"2026-02-21T22:56:14Z","created_by":"Benedikt Schnatterbeck","updated_at":"2026-02-21T23:22:45Z","dependencies":[{"issue_id":"ct-launch","depends_on_id":"ct-cli","type":"blocks","created_at":"2026-02-21T22:57:56Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-launch","depends_on_id":"ct-daemon","type":"blocks","created_at":"2026-02-21T22:57:57Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-launch","depends_on_id":"ct-signal","type":"blocks","created_at":"2026-02-21T22:57:57Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-launch","depends_on_id":"ct-uds","type":"blocks","created_at":"2026-02-21T22:57:56Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"}]}
{"id":"ct-launch.1","title":"Implement lifecycle orchestration logic","description":"In chesstty/src/launch.rs: implement launch_default() that: 1) load config, 2) check is_server_running, 3) if not running: clean stale files + daemonize server, 4) wait_for_socket, 5) launch TUI. Each step has tracing::info. Error at any step produces actionable message.","status":"open","priority":1,"issue_type":"task","owner":"benedikt.schnatterbeck@fresha.com","created_at":"2026-02-21T22:57:42Z","created_by":"Benedikt Schnatterbeck","updated_at":"2026-02-21T23:22:44Z","dependencies":[{"issue_id":"ct-launch.1","depends_on_id":"ct-cli","type":"blocks","created_at":"2026-02-21T23:23:04Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-launch.1","depends_on_id":"ct-daemon","type":"blocks","created_at":"2026-02-21T23:23:05Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-launch.1","depends_on_id":"ct-launch","type":"parent-child","created_at":"2026-02-21T22:57:41Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-launch.1","depends_on_id":"ct-signal","type":"blocks","created_at":"2026-02-21T23:23:04Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-launch.1","depends_on_id":"ct-uds","type":"blocks","created_at":"2026-02-21T23:23:04Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"}]}
{"id":"ct-launch.2","title":"Expose client-tui run function as library","description":"Refactor client-tui so its main logic (ui::run_app or equivalent) is callable as a library function that accepts a socket_path parameter. The shim will call this directly rather than exec'ing the client-tui binary. This requires client-tui to have both a bin target (for standalone use) and a lib target. Add client-tui as a dependency of the chesstty shim crate.","status":"open","priority":2,"issue_type":"task","owner":"benedikt.schnatterbeck@fresha.com","created_at":"2026-02-21T22:57:42Z","created_by":"Benedikt Schnatterbeck","updated_at":"2026-02-21T23:22:44Z","dependencies":[{"issue_id":"ct-launch.2","depends_on_id":"ct-cli","type":"blocks","created_at":"2026-02-21T23:23:05Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-launch.2","depends_on_id":"ct-daemon","type":"blocks","created_at":"2026-02-21T23:23:06Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-launch.2","depends_on_id":"ct-launch","type":"parent-child","created_at":"2026-02-21T22:57:41Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-launch.2","depends_on_id":"ct-signal","type":"blocks","created_at":"2026-02-21T23:23:06Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-launch.2","depends_on_id":"ct-uds","type":"blocks","created_at":"2026-02-21T23:23:05Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"}]}
{"id":"ct-launch.3","title":"Handle daemonize-to-async boundary","description":"The shim has a tricky execution flow: sync (parse CLI) → sync (Daemon::new().start() which forks) → async (wait_for_socket + launch TUI). The daemon child also goes sync → async (create tokio runtime + run server).\n\nDesign main.rs flow:\n1. Parse CLI args (sync, before any fork)\n2. If default mode and server not running:\n   a. Build Daemon with builder pattern:\n      ```rust\n      let stdout = File::create(config.log_path())?;\n      let stderr = stdout.try_clone()?;\n      Daemon::new()\n          .pid_file(config.pid_path())\n          .working_directory(\"/tmp\")\n          .umask(0o027)\n          .stdout(stdout)\n          .stderr(stderr)\n          .start()?;\n      // We are now the daemon — start server\n      let rt = tokio::runtime::Runtime::new()?;\n      rt.block_on(server::run(config.socket_path()))?;\n      return Ok(()); // daemon exits after server stops\n      ```\n   b. The parent process (original shim) continues after Daemon::start() returns via process exit in the fork. But since start() calls exit(0) in the parent, the shim needs to fork BEFORE calling start(), or use a different pattern:\n      - Option A: shim forks a child, child calls Daemon::start(), shim continues\n      - Option B: Daemon::start() returns a DaemonResult enum { Parent | Child } instead of exiting\n      - Option C (recommended): Use std::process::Command to spawn the server binary as a separate process, then daemonize THAT process. Simpler but requires server to be a separate binary (which it already is: chesstty-server).\n\n   **Decision needed**: Will Daemon::start() exit the parent (like daemonize crate), or return a discriminant? If it exits, the shim must fork first to preserve its own continuation. Recommend: Daemon::start() exits parent like the crate does, but the shim spawns a child process first that becomes the daemon. The shim parent waits for socket and launches TUI.\n\n3. Create tokio runtime for shim (after fork decision resolves)\n4. wait_for_socket().await\n5. Launch TUI in foreground\n\nKey constraint: NO tokio runtime may exist before fork(). tokio::main is NOT usable on the top-level main — use explicit Runtime::new() after the fork boundary.","status":"open","priority":2,"issue_type":"task","owner":"benedikt.schnatterbeck@fresha.com","created_at":"2026-02-21T22:57:42Z","created_by":"Benedikt Schnatterbeck","updated_at":"2026-02-21T23:22:44Z","dependencies":[{"issue_id":"ct-launch.3","depends_on_id":"ct-cli","type":"blocks","created_at":"2026-02-21T23:23:06Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-launch.3","depends_on_id":"ct-daemon","type":"blocks","created_at":"2026-02-21T23:23:07Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-launch.3","depends_on_id":"ct-launch","type":"parent-child","created_at":"2026-02-21T22:57:42Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-launch.3","depends_on_id":"ct-signal","type":"blocks","created_at":"2026-02-21T23:23:07Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-launch.3","depends_on_id":"ct-uds","type":"blocks","created_at":"2026-02-21T23:23:07Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"}]}
{"id":"ct-shim","title":"Thin Shim CLI — Process Supervisor \u0026 Entry Point","description":"## What\n\nA \"Thin Shim\" CLI binary (`chesstty`) that acts as the single entry point and process supervisor for the chess TUI application. It replaces the current two-terminal workflow (`just server` + `just tui`) with a single command that:\n\n1. **Default mode (no args)**: Launches the gRPC server as a background daemon (if not already running) and then launches the TUI in the foreground.\n2. **`engine stop` subcommand**: Signals the background server to shut down gracefully (SIGTERM) or immediately (`--force` → SIGKILL).\n\nThe shim introduces Unix Domain Socket communication (replacing TCP `[::1]:50051`), PID file tracking, native server daemonization (custom double-fork, no external crate), and a socket-ready wait loop to ensure the TUI doesn't connect before the server is listening.\n\n## Architecture\n\n```\nchesstty (shim)\n  ├── default: check PID → daemonize server (double-fork) → wait for socket → launch TUI\n  └── engine stop [-f]: read PID → SIGTERM/SIGKILL → cleanup\n\nServer: binds /tmp/chesstty.sock, writes /tmp/chesstty.pid, handles SIGTERM\nClient: connects via UDS, configurable socket path\n```\n\n## New Crate\n\n`chesstty/chesstty/` — added to workspace members in root `Cargo.toml`.\n\n## Key Dependencies\n\n- `clap 4` (derive) — CLI argument parsing\n- `libc 0.2` — custom daemonization (fork/setsid), PID checks, signal sending\n- `tokio-stream` (net feature) — UDS listener stream for tonic\n- `hyper-util` + `tower` — UDS connector for tonic client","status":"open","priority":1,"issue_type":"epic","owner":"benedikt.schnatterbeck@fresha.com","created_at":"2026-02-21T22:54:44Z","created_by":"Benedikt Schnatterbeck","updated_at":"2026-02-21T23:22:46Z"}
{"id":"ct-signal","title":"Server Signal Handling \u0026 Graceful Shutdown","description":"## What\nAdd SIGTERM and SIGINT signal handling to the server so it shuts down gracefully: stops accepting new requests, completes in-flight RPCs, cleans up Stockfish child processes, removes the PID file and socket file, and exits cleanly.\n\n## File(s)\n- `server/src/main.rs` — wrap serve in tokio::select! with signal handler\n- `server/src/shutdown.rs` (new) — shutdown coordination logic\n- `server/src/session/manager.rs` — ensure SessionManager propagates shutdown to actors\n\n## Implementation Details\n```rust\nuse tokio::signal::unix::{signal, SignalKind};\n\nlet mut sigterm = signal(SignalKind::terminate())?;\nlet mut sigint = signal(SignalKind::interrupt())?;\n\ntokio::select! {\n    result = server.serve_with_incoming(uds_stream) =\u003e {\n        result?;\n    }\n    _ = sigterm.recv() =\u003e {\n        tracing::info!(\"Received SIGTERM, shutting down gracefully\");\n    }\n    _ = sigint.recv() =\u003e {\n        tracing::info!(\"Received SIGINT, shutting down gracefully\");\n    }\n}\n\n// Cleanup sequence:\n// 1. Stop accepting new connections\n// 2. Wait for in-flight RPCs to complete (with timeout)\n// 3. Shut down SessionManager (kills Stockfish subprocesses)\n// 4. Remove PID file\n// 5. Remove socket file\n```\n\nConsider using `tokio::sync::watch` to broadcast shutdown signal to all subsystems. The existing `CleanupGuard` (Drop-based) pattern for sessions should integrate with this.\n\n## Acceptance Criteria\n- [ ] Server handles SIGTERM and shuts down within 5 seconds\n- [ ] Server handles SIGINT (Ctrl+C) and shuts down gracefully\n- [ ] PID file is removed on graceful shutdown\n- [ ] Socket file is removed on graceful shutdown\n- [ ] All Stockfish child processes are terminated on shutdown\n- [ ] In-flight RPCs complete before server exits (with timeout)\n- [ ] Server logs shutdown sequence via tracing","status":"open","priority":1,"issue_type":"task","owner":"benedikt.schnatterbeck@fresha.com","created_at":"2026-02-21T22:55:39Z","created_by":"Benedikt Schnatterbeck","updated_at":"2026-02-21T23:22:20Z","dependencies":[{"issue_id":"ct-signal","depends_on_id":"ct-uds","type":"blocks","created_at":"2026-02-21T22:57:56Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"}]}
{"id":"ct-signal.1","title":"Add tokio signal handlers for SIGTERM and SIGINT","description":"In server main.rs or a new shutdown.rs module: create tokio::signal::unix::signal(SignalKind::terminate()) and signal(SignalKind::interrupt()). Wrap the serve call in tokio::select! { server.serve_with_incoming(stream) =\u003e ..., sigterm.recv() =\u003e log + begin shutdown, sigint.recv() =\u003e log + begin shutdown }. On signal, initiate graceful shutdown.","status":"open","priority":1,"issue_type":"task","owner":"benedikt.schnatterbeck@fresha.com","created_at":"2026-02-21T22:57:39Z","created_by":"Benedikt Schnatterbeck","updated_at":"2026-02-21T23:22:11Z","dependencies":[{"issue_id":"ct-signal.1","depends_on_id":"ct-signal","type":"parent-child","created_at":"2026-02-21T22:57:39Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-signal.1","depends_on_id":"ct-uds","type":"blocks","created_at":"2026-02-21T23:23:00Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"}]}
{"id":"ct-signal.2","title":"Implement shutdown coordination via watch channel","description":"Create a tokio::sync::watch::channel(false) for shutdown signal. On SIGTERM/SIGINT, send true. Pass the watch::Receiver to SessionManager and ReviewManager so they can observe shutdown. Use serve_with_incoming_shutdown() if available, or manually select on the watch channel. Integrate with existing CleanupGuard pattern for session cleanup.","status":"open","priority":1,"issue_type":"task","owner":"benedikt.schnatterbeck@fresha.com","created_at":"2026-02-21T22:57:40Z","created_by":"Benedikt Schnatterbeck","updated_at":"2026-02-21T23:22:14Z","dependencies":[{"issue_id":"ct-signal.2","depends_on_id":"ct-signal","type":"parent-child","created_at":"2026-02-21T22:57:39Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-signal.2","depends_on_id":"ct-uds","type":"blocks","created_at":"2026-02-21T23:23:00Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"}]}
{"id":"ct-signal.3","title":"Add PID and socket file cleanup on shutdown","description":"After graceful shutdown completes (serve returns): remove PID file at config::pid_path() and socket file at config::socket_path(). Use a Drop guard or explicit cleanup function. Log each cleanup step. Handle errors gracefully (file already removed, permission denied).","status":"open","priority":2,"issue_type":"task","owner":"benedikt.schnatterbeck@fresha.com","created_at":"2026-02-21T22:57:40Z","created_by":"Benedikt Schnatterbeck","updated_at":"2026-02-21T23:22:17Z","dependencies":[{"issue_id":"ct-signal.3","depends_on_id":"ct-signal","type":"parent-child","created_at":"2026-02-21T22:57:40Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-signal.3","depends_on_id":"ct-uds","type":"blocks","created_at":"2026-02-21T23:23:00Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"}]}
{"id":"ct-stop","title":"'engine stop' Subcommand \u0026 Integration Tests","description":"## What\nImplement the `engine stop` subcommand that reads the PID file and sends the appropriate signal to the server. Also add integration tests covering all lifecycle edge cases.\n\n## File(s)\n- `chesstty/chesstty/src/stop.rs` (new) — stop command implementation\n- `chesstty/chesstty/src/main.rs` — wire stop handler to CLI dispatch\n- `chesstty/chesstty/tests/integration.rs` (new) — integration tests\n\n## Implementation Details\n\n### Graceful Stop (default)\n```rust\npub fn stop_server(pid_path: \u0026Path, force: bool) -\u003e anyhow::Result\u003c()\u003e {\n    let pid = process::read_pid(pid_path)?;\n\n    if force {\n        tracing::warn!(\"Force-killing server (PID {pid})\");\n        unsafe { libc::kill(pid, libc::SIGKILL); }\n    } else {\n        tracing::info!(\"Sending SIGTERM to server (PID {pid})\");\n        unsafe { libc::kill(pid, libc::SIGTERM); }\n\n        // Wait for process to exit (poll with timeout)\n        let deadline = Instant::now() + Duration::from_secs(10);\n        while Instant::now() \u003c deadline {\n            if unsafe { libc::kill(pid, 0) } != 0 {\n                tracing::info!(\"Server stopped\");\n                break;\n            }\n            std::thread::sleep(Duration::from_millis(100));\n        }\n\n        // If still running after timeout, warn user\n        if unsafe { libc::kill(pid, 0) } == 0 {\n            tracing::warn!(\"Server did not stop within 10s. Use --force to kill.\");\n            anyhow::bail!(\"Server did not stop gracefully\");\n        }\n    }\n\n    // Clean up stale files\n    process::remove_stale_pid(pid_path)?;\n    let socket_path = config::socket_path();\n    if socket_path.exists() {\n        std::fs::remove_file(\u0026socket_path)?;\n    }\n\n    Ok(())\n}\n```\n\n### Integration Test Scenarios\n1. **Server already running** — default launch skips daemon, connects TUI\n2. **Stale PID file** — dead process, shim cleans up and launches new server\n3. **Socket wait timeout** — server fails to start, shim reports clear error\n4. **Graceful stop** — SIGTERM, server cleans up, files removed\n5. **Force stop** — SIGKILL, shim cleans up stale files\n6. **Double stop** — `engine stop` when server not running → clean error\n7. **No PID file** — `engine stop` with no server → clean error\n\n## Acceptance Criteria\n- [ ] `chesstty engine stop` sends SIGTERM and waits for server exit\n- [ ] `chesstty engine stop --force` sends SIGKILL immediately\n- [ ] Clean error message when no server is running\n- [ ] Clean error message when PID file doesn't exist\n- [ ] Stale PID/socket files are cleaned up after stop\n- [ ] Integration tests cover all 7 scenarios above\n- [ ] `unsafe` blocks for libc::kill are minimal and well-documented","status":"open","priority":2,"issue_type":"task","owner":"benedikt.schnatterbeck@fresha.com","created_at":"2026-02-21T22:56:28Z","created_by":"Benedikt Schnatterbeck","updated_at":"2026-02-21T23:22:46Z","dependencies":[{"issue_id":"ct-stop","depends_on_id":"ct-cli","type":"blocks","created_at":"2026-02-21T22:57:58Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-stop","depends_on_id":"ct-daemon","type":"blocks","created_at":"2026-02-21T22:57:58Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-stop","depends_on_id":"ct-signal","type":"blocks","created_at":"2026-02-21T22:57:58Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"}]}
{"id":"ct-stop.1","title":"Implement graceful stop via SIGTERM","description":"In chesstty/src/stop.rs: read_pid from PID file, send libc::kill(pid, libc::SIGTERM), poll libc::kill(pid, 0) with 10s timeout to confirm exit. On success: remove stale PID/socket files, print confirmation. On timeout: print warning suggesting --force. On no PID file: print 'server is not running'.","status":"open","priority":1,"issue_type":"task","owner":"benedikt.schnatterbeck@fresha.com","created_at":"2026-02-21T22:57:43Z","created_by":"Benedikt Schnatterbeck","updated_at":"2026-02-21T23:22:45Z","dependencies":[{"issue_id":"ct-stop.1","depends_on_id":"ct-cli","type":"blocks","created_at":"2026-02-21T23:23:09Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-stop.1","depends_on_id":"ct-daemon","type":"blocks","created_at":"2026-02-21T23:23:10Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-stop.1","depends_on_id":"ct-signal","type":"blocks","created_at":"2026-02-21T23:23:09Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-stop.1","depends_on_id":"ct-stop","type":"parent-child","created_at":"2026-02-21T22:57:42Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"}]}
{"id":"ct-stop.2","title":"Implement force stop via SIGKILL","description":"When --force flag is set: send libc::kill(pid, libc::SIGKILL) instead of SIGTERM. SIGKILL cannot be caught, so the server won't clean up its own files. The shim must clean up PID file and socket file after SIGKILL. Brief sleep(100ms) after SIGKILL before cleanup.","status":"open","priority":1,"issue_type":"task","owner":"benedikt.schnatterbeck@fresha.com","created_at":"2026-02-21T22:57:43Z","created_by":"Benedikt Schnatterbeck","updated_at":"2026-02-21T23:22:45Z","dependencies":[{"issue_id":"ct-stop.2","depends_on_id":"ct-cli","type":"blocks","created_at":"2026-02-21T23:23:10Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-stop.2","depends_on_id":"ct-daemon","type":"blocks","created_at":"2026-02-21T23:23:11Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-stop.2","depends_on_id":"ct-signal","type":"blocks","created_at":"2026-02-21T23:23:10Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-stop.2","depends_on_id":"ct-stop","type":"parent-child","created_at":"2026-02-21T22:57:43Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"}]}
{"id":"ct-stop.3","title":"Integration test suite for all lifecycle scenarios","description":"In chesstty/tests/integration.rs or tests/ directory: test all scenarios: 1) fresh start (no server) -\u003e launches daemon + TUI connects, 2) server already running -\u003e skips launch, 3) stale PID (dead process) -\u003e cleanup + relaunch, 4) socket timeout -\u003e clear error, 5) graceful stop -\u003e SIGTERM + cleanup, 6) force stop -\u003e SIGKILL + cleanup, 7) stop with no server -\u003e error message, 8) double stop -\u003e idempotent. Use tempdir for PID/socket files in tests. May need #[ignore] for some tests that require actual process forking.","status":"open","priority":2,"issue_type":"task","owner":"benedikt.schnatterbeck@fresha.com","created_at":"2026-02-21T22:57:43Z","created_by":"Benedikt Schnatterbeck","updated_at":"2026-02-21T23:22:46Z","dependencies":[{"issue_id":"ct-stop.3","depends_on_id":"ct-cli","type":"blocks","created_at":"2026-02-21T23:23:11Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-stop.3","depends_on_id":"ct-daemon","type":"blocks","created_at":"2026-02-21T23:23:12Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-stop.3","depends_on_id":"ct-signal","type":"blocks","created_at":"2026-02-21T23:23:12Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-stop.3","depends_on_id":"ct-stop","type":"parent-child","created_at":"2026-02-21T22:57:43Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"}]}
{"id":"ct-uds","title":"Unix Domain Socket Communication Layer","description":"## What\nMigrate server and client from TCP `[::1]:50051` to Unix Domain Socket communication. The server binds a UDS listener, and the client connects via UDS. This is prerequisite for the shim to manage the server as a local daemon.\n\n## File(s)\n- `server/src/main.rs` — replace `.serve(addr)\\ with `.serve_with_incoming(uds_stream)`\n- `server/Cargo.toml` — add tokio-stream dependency\n- `chess-client/src/client.rs` — add UDS connect method using tower connector\n- `chess-client/Cargo.toml` — add hyper-util, tower deps (already has tower 0.5, hyper 1.5)\n- `client-tui/src/main.rs` — update connection to use UDS path\n\n## Implementation Details\n\n### Server UDS Binding\n```rust\nuse tokio::net::UnixListener;\nuse tokio_stream::wrappers::UnixListenerStream;\n\n// Clean up stale socket file\nlet socket_path = config::socket_path();\nif socket_path.exists() {\n    std::fs::remove_file(\u0026socket_path)?;\n}\n\nlet uds = UnixListener::bind(\u0026socket_path)?;\nlet uds_stream = UnixListenerStream::new(uds);\n\nServer::builder()\n    .add_service(ChessServiceServer::new(service))\n    .serve_with_incoming(uds_stream)\n    .await?;\n```\n\n### Client UDS Connection (tonic snippet)\n```rust\nuse hyper_util::rt::TokioIo;\nuse tokio::net::UnixStream;\nuse tonic::transport::{Channel, Endpoint, Uri};\nuse tower::service_fn;\n\nlet channel = Endpoint::try_from(\"http://[::]:50051\")?\n    .connect_with_connector(service_fn(move |_: Uri| {\n        let path = socket_path.clone();\n        async move {\n            Ok::\u003c_, std::io::Error\u003e(TokioIo::new(UnixStream::connect(path).await?))\n        }\n    }))\n    .await?;\nlet client = ChessServiceClient::new(channel);\n```\n\nNote: The Endpoint URI is a dummy — tonic requires it but the connector ignores it.\n\n## Acceptance Criteria\n- [ ] Server binds to UDS at configured socket path (default /tmp/chesstty.sock)\n- [ ] Server removes stale socket file before binding\n- [ ] Client connects to server via UDS (not TCP)\n- [ ] All 25 gRPC RPCs work over UDS (existing tests pass)\n- [ ] Socket file is created with appropriate permissions\n- [ ] `tokio-stream` (net feature) added to server deps\n- [ ] TCP fallback is NOT required (clean migration)","status":"open","priority":1,"issue_type":"task","owner":"benedikt.schnatterbeck@fresha.com","created_at":"2026-02-21T22:55:27Z","created_by":"Benedikt Schnatterbeck","updated_at":"2026-02-21T23:22:08Z","dependencies":[{"issue_id":"ct-uds","depends_on_id":"ct-config","type":"blocks","created_at":"2026-02-21T22:57:55Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"}]}
{"id":"ct-uds.1","title":"Server: Replace TCP bind with UDS listener","description":"In server/src/main.rs: import tokio::net::UnixListener and tokio_stream::wrappers::UnixListenerStream. Replace the .serve(addr.parse()?) call with: remove stale socket file -\u003e UnixListener::bind(socket_path) -\u003e UnixListenerStream::new(uds) -\u003e .serve_with_incoming(uds_stream). Add tokio-stream = { version = \"0.1\", features = [\"net\"] } to server/Cargo.toml. Log the socket path at startup.","status":"open","priority":1,"issue_type":"task","owner":"benedikt.schnatterbeck@fresha.com","created_at":"2026-02-21T22:57:38Z","created_by":"Benedikt Schnatterbeck","updated_at":"2026-02-21T23:21:59Z","dependencies":[{"issue_id":"ct-uds.1","depends_on_id":"ct-config","type":"blocks","created_at":"2026-02-21T23:22:59Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-uds.1","depends_on_id":"ct-uds","type":"parent-child","created_at":"2026-02-21T22:57:38Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"}]}
{"id":"ct-uds.2","title":"Client: Add UDS connector to chess-client","description":"In chess-client/src/client.rs: add a new connect_uds(socket_path: \u0026Path) method (or modify existing connect). Use Endpoint::try_from(\"http://[::]:50051\")?.connect_with_connector(service_fn(...)) pattern with TokioIo\u003cUnixStream\u003e. chess-client already has tower 0.5 and hyper 1.5 deps; add hyper-util for TokioIo. Keep the old TCP connect method for backward compat if needed.","status":"open","priority":1,"issue_type":"task","owner":"benedikt.schnatterbeck@fresha.com","created_at":"2026-02-21T22:57:39Z","created_by":"Benedikt Schnatterbeck","updated_at":"2026-02-21T23:22:02Z","dependencies":[{"issue_id":"ct-uds.2","depends_on_id":"ct-config","type":"blocks","created_at":"2026-02-21T23:22:59Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-uds.2","depends_on_id":"ct-uds","type":"parent-child","created_at":"2026-02-21T22:57:38Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"}]}
{"id":"ct-uds.3","title":"Client-tui: Update connection to use UDS path","description":"In client-tui/src/main.rs (or wherever ui::run_app is configured): replace the hardcoded 'http://[::1]:50051' with a call to config::socket_path() and use ChessClient::connect_uds(). The socket path should come from shared config. Consider making run_app accept a socket_path parameter for the library-call pattern from T6.","status":"open","priority":2,"issue_type":"task","owner":"benedikt.schnatterbeck@fresha.com","created_at":"2026-02-21T22:57:39Z","created_by":"Benedikt Schnatterbeck","updated_at":"2026-02-21T23:22:05Z","dependencies":[{"issue_id":"ct-uds.3","depends_on_id":"ct-config","type":"blocks","created_at":"2026-02-21T23:22:59Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"},{"issue_id":"ct-uds.3","depends_on_id":"ct-uds","type":"parent-child","created_at":"2026-02-21T22:57:39Z","created_by":"Benedikt Schnatterbeck","metadata":"{}"}]}
