use crate::client::ChessClient;
use crate::converters;
use chess_proto::*;
use cozy_chess::{Color, Piece, Square};
use std::collections::HashMap;

/// Client-side application state that communicates with the server
pub struct ClientState {
    pub client: ChessClient,
    pub mode: GameMode,
    pub skill_level: u8,
    pub ui_state: UiState,

    // Cached game state from server
    cached_fen: String,
    cached_side_to_move: String,
    cached_status: i32,
    cached_history: Vec<MoveRecord>,
    legal_moves_cache: HashMap<String, Vec<MoveDetail>>,
}

/// Game mode determines how the app behaves
#[derive(Debug, Clone, PartialEq)]
pub enum GameMode {
    HumanVsHuman,
    HumanVsEngine { human_side: PlayerColor },
    EngineVsEngine,
    AnalysisMode,
    ReviewMode,
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum PlayerColor {
    White,
    Black,
}

/// UI-specific state (not part of game state)
pub struct UiState {
    pub selected_square: Option<Square>,
    pub highlighted_squares: Vec<Square>,
    pub selectable_squares: Vec<Square>,
    pub last_move: Option<(Square, Square)>,
    pub engine_info: Option<EngineInfo>,
    pub status_message: Option<String>,
    pub input_phase: InputPhase,
    pub show_debug_panel: bool,
    pub uci_log: Vec<UciLogEntry>,
    pub selected_promotion_piece: Piece,
}

#[derive(Debug, Clone)]
pub struct UciLogEntry {
    pub direction: UciDirection,
    pub message: String,
    pub timestamp: std::time::Instant,
    pub move_context: Option<String>,
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum UciDirection {
    ToEngine,
    FromEngine,
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum InputPhase {
    SelectPiece,
    SelectDestination,
    SelectPromotion { from: Square, to: Square },
}

impl ClientState {
    /// Create a new client state (must connect to server first)
    pub async fn new(server_addr: &str) -> Result<Self, Box<dyn std::error::Error>> {
        let mut client = ChessClient::connect(server_addr).await?;

        // Create a new session on the server
        let session_info = client.create_session(None).await?;

        let mut state = Self {
            client,
            mode: GameMode::HumanVsHuman,
            skill_level: 10,
            ui_state: UiState {
                selected_square: None,
                highlighted_squares: Vec::new(),
                selectable_squares: Vec::new(),
                last_move: None,
                engine_info: None,
                status_message: None,
                input_phase: InputPhase::SelectPiece,
                show_debug_panel: false,
                uci_log: Vec::new(),
                selected_promotion_piece: Piece::Queen,
            },
            cached_fen: session_info.fen.clone(),
            cached_side_to_move: session_info.side_to_move.clone(),
            cached_status: session_info.status,
            cached_history: session_info.history,
            legal_moves_cache: HashMap::new(),
        };

        state.update_selectable_squares().await?;
        Ok(state)
    }

    /// Get the current FEN position
    pub fn fen(&self) -> &str {
        &self.cached_fen
    }

    /// Get the side to move
    pub fn side_to_move(&self) -> &str {
        &self.cached_side_to_move
    }

    /// Get game status
    pub fn status(&self) -> i32 {
        self.cached_status
    }

    /// Get move history
    pub fn history(&self) -> &[MoveRecord] {
        &self.cached_history
    }

    /// Check if it's the engine's turn to move
    pub fn is_engine_turn(&self) -> bool {
        match self.mode {
            GameMode::HumanVsEngine { human_side } => {
                let is_white_turn = self.cached_side_to_move == "white";
                match human_side {
                    PlayerColor::White => !is_white_turn,
                    PlayerColor::Black => is_white_turn,
                }
            }
            GameMode::EngineVsEngine => true,
            _ => false,
        }
    }

    /// Make a move with the engine
    pub async fn make_engine_move(&mut self) -> Result<(), String> {
        if !self.is_engine_turn() {
            return Ok(());
        }

        // Check if game is ongoing
        if self.cached_status != GameStatus::Ongoing as i32 {
            return Ok(());
        }

        self.ui_state.status_message = Some("Engine thinking...".to_string());

        // Trigger engine move on server
        self.client
            .trigger_engine_move(None)
            .await
            .map_err(|e| e.to_string())?;

        // TODO: Set up event streaming to receive engine move
        // For now, we'll poll for the move in the main loop

        Ok(())
    }

    /// Update the list of squares with pieces that can be selected
    pub async fn update_selectable_squares(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        // Get all legal moves from server
        let moves = self.client.get_legal_moves(None).await?;

        // Extract unique "from" squares
        let mut from_squares: Vec<String> = moves.iter().map(|m| m.from.clone()).collect();
        from_squares.sort();
        from_squares.dedup();

        self.ui_state.selectable_squares = from_squares;

        // Cache legal moves by from square
        self.legal_moves_cache.clear();
        for mv in moves {
            self.legal_moves_cache
                .entry(mv.from.clone())
                .or_insert_with(Vec::new)
                .push(mv);
        }

        Ok(())
    }

    /// Filter selectable squares by partial input (typeahead)
    pub fn filter_selectable_by_input(&self, input: &str) -> Vec<String> {
        if input.is_empty() {
            return vec![];
        }

        self.ui_state
            .selectable_squares
            .iter()
            .filter(|sq| sq.starts_with(input))
            .cloned()
            .collect()
    }

    /// Select a square and highlight legal moves for the piece on it
    pub fn select_square(&mut self, square: String) {
        // Check if this square is selectable (has a piece of the current player)
        if !self.ui_state.selectable_squares.contains(&square) {
            self.ui_state.status_message =
                Some("No piece on that square or not your turn".to_string());
            return;
        }

        // Get legal moves for this square from cache
        if let Some(moves) = self.legal_moves_cache.get(&square) {
            self.ui_state.selected_square = Some(square.clone());
            self.ui_state.highlighted_squares = moves.iter().map(|m| m.to.clone()).collect();
            self.ui_state.input_phase = InputPhase::SelectDestination;
            self.ui_state.status_message = Some(format!("Selected {}", square));
        } else {
            self.ui_state.status_message = Some("No legal moves from that square".to_string());
        }
    }

    /// Attempt to move the selected piece to the destination square
    pub async fn try_move_to(&mut self, to_square: String) -> Result<(), String> {
        let from_square = self
            .ui_state
            .selected_square
            .as_ref()
            .ok_or("No piece selected")?
            .clone();

        // Check if this destination is in the highlighted (legal) moves
        if !self.ui_state.highlighted_squares.contains(&to_square) {
            return Err("Illegal move".to_string());
        }

        // Check if this is a pawn promotion
        let needs_promotion = {
            if let Some(moves) = self.legal_moves_cache.get(&from_square) {
                moves
                    .iter()
                    .any(|m| m.to == to_square && m.promotion.is_some())
            } else {
                false
            }
        };

        if needs_promotion {
            // Transition to promotion selection phase
            self.ui_state.input_phase = InputPhase::SelectPromotion {
                from: from_square,
                to: to_square,
            };
            self.ui_state.selected_promotion_piece = "q".to_string();
            self.ui_state.status_message = Some("Select promotion piece".to_string());
            return Ok(());
        }

        // Make the move on the server
        let response = self
            .client
            .make_move(&from_square, &to_square, None)
            .await
            .map_err(|e| e.to_string())?;

        // Update cached state
        if let Some(session_info) = response.session_info {
            self.update_from_session_info(session_info);
        }

        // Update UI state
        self.ui_state.last_move = Some((from_square.clone(), to_square.clone()));
        self.ui_state.selected_square = None;
        self.ui_state.highlighted_squares.clear();
        self.ui_state.input_phase = InputPhase::SelectPiece;
        self.ui_state.status_message = Some(format!("Moved {} to {}", from_square, to_square));

        self.update_selectable_squares()
            .await
            .map_err(|e| e.to_string())?;

        Ok(())
    }

    /// Execute a promotion move after piece selection
    pub async fn execute_promotion(
        &mut self,
        from: String,
        to: String,
        piece: String,
    ) -> Result<(), String> {
        // Make the move on the server with promotion
        let response = self
            .client
            .make_move(&from, &to, Some(piece.clone()))
            .await
            .map_err(|e| e.to_string())?;

        // Update cached state
        if let Some(session_info) = response.session_info {
            self.update_from_session_info(session_info);
        }

        // Update UI state
        self.ui_state.last_move = Some((from.clone(), to.clone()));
        self.ui_state.selected_square = None;
        self.ui_state.highlighted_squares.clear();
        self.ui_state.input_phase = InputPhase::SelectPiece;
        self.ui_state.status_message = Some(format!("Promoted to {}", piece));

        self.update_selectable_squares()
            .await
            .map_err(|e| e.to_string())?;

        Ok(())
    }

    /// Cancel promotion selection and return to piece selection
    pub fn cancel_promotion(&mut self) {
        self.ui_state.selected_square = None;
        self.ui_state.highlighted_squares.clear();
        self.ui_state.input_phase = InputPhase::SelectPiece;
        self.ui_state.status_message = Some("Promotion cancelled".to_string());
    }

    /// Cycle promotion piece selection
    pub fn cycle_promotion_piece(&mut self, direction: i8) {
        let pieces = ["q", "r", "b", "n"];
        let current_idx = pieces
            .iter()
            .position(|&p| p == self.ui_state.selected_promotion_piece)
            .unwrap_or(0);

        let new_idx = if direction > 0 {
            (current_idx + 1) % pieces.len()
        } else if direction < 0 {
            (current_idx + pieces.len() - 1) % pieces.len()
        } else {
            current_idx
        };

        self.ui_state.selected_promotion_piece = pieces[new_idx].to_string();
    }

    /// Set promotion piece directly
    pub fn set_promotion_piece(&mut self, piece: String) {
        self.ui_state.selected_promotion_piece = piece;
    }

    /// Clear the current selection and highlights
    pub fn clear_selection(&mut self) {
        self.ui_state.selected_square = None;
        self.ui_state.highlighted_squares.clear();
        self.ui_state.input_phase = InputPhase::SelectPiece;
        self.ui_state.status_message = None;
    }

    /// Clear all UI highlights and state
    pub fn clear_all_highlights(&mut self) {
        self.clear_selection();
    }

    /// Toggle debug panel visibility
    pub fn toggle_debug_panel(&mut self) {
        self.ui_state.show_debug_panel = !self.ui_state.show_debug_panel;
    }

    /// Log a UCI message
    pub fn log_uci_message(
        &mut self,
        direction: UciDirection,
        message: String,
        move_context: Option<String>,
    ) {
        self.ui_state.uci_log.push(UciLogEntry {
            direction,
            message,
            timestamp: std::time::Instant::now(),
            move_context,
        });

        // Keep only last 100 messages
        if self.ui_state.uci_log.len() > 100 {
            self.ui_state.uci_log.remove(0);
        }
    }

    /// Undo the last move
    pub async fn undo(&mut self) -> Result<(), String> {
        let session_info = self.client.undo_move().await.map_err(|e| e.to_string())?;

        self.update_from_session_info(session_info);
        self.update_selectable_squares()
            .await
            .map_err(|e| e.to_string())?;

        self.ui_state.status_message = Some("Move undone".to_string());
        Ok(())
    }

    /// Reset the game
    pub async fn reset(&mut self, fen: Option<String>) -> Result<(), String> {
        let session_info = self
            .client
            .reset_game(fen)
            .await
            .map_err(|e| e.to_string())?;

        self.update_from_session_info(session_info);
        self.update_selectable_squares()
            .await
            .map_err(|e| e.to_string())?;

        self.clear_selection();
        self.ui_state.status_message = Some("Game reset".to_string());
        Ok(())
    }

    /// Set engine configuration
    pub async fn set_engine(&mut self, enabled: bool, skill_level: u8) -> Result<(), String> {
        self.skill_level = skill_level;

        self.client
            .set_engine(enabled, skill_level as u32)
            .await
            .map_err(|e| e.to_string())?;

        Ok(())
    }

    /// Update cached state from server SessionInfo
    fn update_from_session_info(&mut self, info: SessionInfo) {
        self.cached_fen = info.fen;
        self.cached_side_to_move = info.side_to_move;
        self.cached_status = info.status;
        self.cached_history = info.history;
    }

    /// Refresh state from server
    pub async fn refresh(&mut self) -> Result<(), String> {
        let session_info = self.client.get_session().await.map_err(|e| e.to_string())?;

        self.update_from_session_info(session_info);
        self.update_selectable_squares()
            .await
            .map_err(|e| e.to_string())?;

        Ok(())
    }
}

impl Drop for ClientState {
    fn drop(&mut self) {
        // Best effort to close the session
        // We can't await here, so we'll just drop the connection
    }
}
